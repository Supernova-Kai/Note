# 内存加密
### 前言
在游戏开发中，不可避免的会遇到玩家作弊的情况，作弊有各种方式，本文讲解最常见的一种，即修改内存作弊

# 作弊原理

首先，我们要反制玩家作弊，就要先知道他是如何作弊的，也就是知己知彼

其中一种最常见的方式便是利用`Cheat Engine`等软件，对游戏运行中的内存进行扫描，来确定他想要修改的值在内存中的地址，确定之后就可以直接修改内存来达到作弊的目的

### 演示场景

首先我们搭建一个用于演示作弊的`Unity`场景，如下

![alt text](Image/内存加密1.png)

在这个场景中，有两个组件，其中`Text`显示敌人剩余血量，按钮用于攻击敌人

接下来，我们来编写界面对应的脚本
```csharp
using UnityEngine;
using UnityEngine.UI;

public class UIMain : MonoBehaviour
{
    [SerializeField] private Text txtHp;
    [SerializeField] private Button btnAttack;

    private int hp;
    
    private void Awake()
    {
        hp = 1000;
        btnAttack.onClick.AddListener(() =>
        {
            hp -= 1;
            RefreshUI();
        });
    }

    private void RefreshUI()
    {
        txtHp.text = "敌人血量=" + hp;
    }

    private void OnEnable()
    {
        RefreshUI();
    }
}
```

脚本非常简单，我们定义了一个`hp`字段代表敌人的血量，初始为`1000`

每次点击按钮的时候，会攻击一下敌人，敌人血量减少`1`

### 使用CE作弊

那么，根据我们的逻辑，攻击一次敌人只能扣敌人`1`点血，而敌人一共有`1000`点血，玩家需要点`1000`下才能打死敌人，玩家觉得这个游戏太难了，他开始利用`CE`软件作弊

![alt text](Image/内存加密2.gif)

首先，启动游戏和`CE`，将`CE`扫描的进程指定为这个`Unity`项目

第一次扫描，最开始界面上显示敌人的血量为`1000`，我们在右侧输入`1000`，并点击`First Scan`，也就是第一次扫描，此时`CE`就可以扫描出所有值为`1000`的内存地址

接下来，我们攻击一次敌人，此时敌人的血量变为`999`，此时我们输入`999`，并点击`Next Scan`，这样`CE`就会自动比对上一次的结果与这一次的结果，找到上一次是`1000`的内存，以及当前值是`999`的内存，此时我们左侧的列表中，就只剩下了一个内存地址了，我们可以基本确定这个内存就是游戏中存储“敌人血量”的内存

此时，右键该内存，选择第二个选项，修改该内存的值，将其修改为`5`，此时我们的敌人血量就只剩下`5`了，我们再攻击敌人，发现只需要再攻击`4`下，敌人就死掉了


注意，实际使用过程中，不一定能一步就找到内存，如果每一步剩下的不止一个地址，我们可以不断重复“操作并扫描”这一过程，来不断缩小内存的范围，直到直到为止

# 反制作弊

通过上面的场景，我们知道了修改内存作弊的原理，那么我们怎么反制呢？

其中一个思路便是，我们在内存中不存储原始数据，对原始数据进行加密，这样玩家“看到的”数据实际在内存中是不存在的，便无法通过扫描来确定地址

那么，有什么方式可以对一个数据进行加密，又可以原封不动的解密呢？

### 异或运算
对于异或运算，有以下规则（**同为0，异为1**）
```csharp
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0
```

|原数据(a)|密钥(b)|a^b(加密，后文称c)|c^b(解密)
|-|-|-|-|
|1|1|0|1
|1|0|1|1
|0|1|1|0
|0|0|0|0

我们可以发现，当原数据与密钥进行一次异或，得到加密后的值，再将该值与密钥进行一次异或，可以还原为原数据

### 具体设计

```csharp
using System;

public class SecurityMgr
{
    // 单例
    private static SecurityMgr _instance;

    public static SecurityMgr Instance
    {
        get
        {
            if (_instance == null)
                _instance = new SecurityMgr();
            return _instance;
        }
    }

    private SecurityMgr()
    {
        
    }

    private Random random = new Random();

    // 获取一个随机密钥
    public int GetRandomSecurityKey()
    {
        return random.Next();
    }
}

// int类型对的加密类型
public class SecurityInt
{
    private int _securityKey; // 密钥(每一个加密值的密钥都是单独的)
    private int _encryptedValue; // 加密后的值

    public void SetValue(int value)
    {
        // 每次设置值都更新密钥
        _securityKey = SecurityMgr.Instance.GetRandomSecurityKey();
        _encryptedValue = value ^ _securityKey;
    }

    public int GetValue()
    {
        return _encryptedValue ^ _securityKey;
    }
}
```

```csharp
// 真正存储数据的对象
private SecurityInt _securityHp = new SecurityInt();

// 访问改为使用属性，调用_securityHp上的方法来获取原始数据
public int hp
{
    set => _securityHp.SetValue(value); // 设置值
    get => _securityHp.GetValue(); // 获取值
}
```


上面便是具体的设计，每一个需要加密的值都是一个`SecurityInt`对象，而每一个`SecurityInt`对象都有自己独立的密钥（尽量不要使用全局密钥），并且每一次设置值时还会重新随机生成密钥，最大化的防止了玩家扫描内存来作弊


# 队列（Queue）
队列是一种遵循**先进先出**（FIFO，First-In-First-Out）的线性存储数据结构
### 特性

- 只能在队尾添加元素（入队），在队头进行删除元素（出队）
- 访问元素仅支持查看队头元素（Peek）
- 不支持随机访问元素，无法像数组那样通过下标访问任意位置的元素，必须通过出队操作逐步移除队头元素，才能访问中间或队尾的元素
# 底层原理
队列的核心是**先进先出**的操作规则，其底层本质是限制了操作位置的动态数组—— 仅允许在队尾添加、队头删除，因此只需通过两个变量记录队头和队尾位置，就能维护队列的逻辑结构

C#的队列其存储结构也是基于动态数组，依赖队头和队尾的两个标记来限制操作，大致如下：
```csharp
T[] _array;    // T类型的数组用于存储元素
int _count;    // 队列中有效元素的个数（即 Queue.Count属性）
int _capacity; // 数组实际分配的空间长度（即 Queue.Capacity属性，避免频繁扩容）
int _head;     // 标记队头位置（指向队列中第一个元素的索引）
int _tail;     // 标记队尾位置（指向队列中下一个要入队的空闲位置索引）
```
### 核心逻辑
通过`_head`和`_tail`两个标记维护队列的有效范围，当入队时更新`_tail`，出队时更新`_head`，当空间不足时，同样有List的扩容机制
### 循环复用机制
队列与栈不同，其有另一个特性，便是循环复用，假设我们有下面这样的一种使用场景：

1. 首先创建一个空队列，假设初始长度为8
2. 向队列中添加7个元素，此时`_tail`指针指向下一个可以入队的索引，也就是7
3. 此时从队头删除3个元素，此时`_head`指针指向第四个元素的索引，即3

在上诉场景中，最终我们的队列数组长度为8，`_tail=7`，`_head`指针指向队头元素，由于我们删了三个元素，应该指向第四个元素，即`_head=3`（指针记录的是索引）

此时，我们继续向队列添加元素，添加元素之后，`_tail`后面已经没有闲置空间了，那它应该指向哪里呢？
这时我们发现，数组的前三个位置当前是没有在使用的，那么我们可以讲`_tail`指针绕回数组的最前面，继续复用其空间

总结如下：
循环复用的核心是「指针绕回」：用 `(指针 + 1) % _capacity` 实现：当指针到达数组末尾（即，索引 = _capacity - 1）时，+1 后取模会得到 0，指针绕回数组开头
### 扩容机制
还是上面这个场景，当我们的`_tail`指针绕回来之后，此时`_tail=0`，`_head=3`，我们继续添加元素，再添加三个元素之后，我们用完了数组的空间，触发扩容，队列会被重新分配一个两倍于之前空间的数组，也就是长度为16的新数组

那么，此时两个指针和数据怎么办呢？

数据会按照从队头到队尾的顺序拷贝到新数组，而`_head`指针和`_tail`指针指向新的队头和队尾，也就是`_head=0`，`_tail=8`
# 关键操作
### 入队（Enqueue）
入队，即向队尾指针位置添加一个元素
```csharp
public void Enqueue(T value)
{
    // 先判断数组容量是否充足，不足则扩容（通常翻倍）
    if (_count == _capacity)
    {
        Resize(_capacity * 2);
    }
    
    _array[_tail] = value; // 空闲位置存入元素
    _tail = (_tail + 1) % _capacity; // 指针后移，遇数组末尾则绕回开头（循环复用）
    _count++; // 有效元素个数+1
}
```
时间复杂度：
- 不涉及扩容时： $O(1)$，直接操作`_tail`指针位置
- 涉及扩容时： $O(n)$，涉及重新分配内存和拷贝元素到新数组
### 出队（Dequeue）
出队，即从队头指针位置返回并移除元素
```csharp
public T Dequeue()
{
    T item = _array[_head]; // 取出队头元素
    _array[_head] = default; // 清除原队头引用（帮助GC回收，可选）
    _head = (_head + 1) % _capacity; // 指针后移，遇数组末尾则绕回开头（循环复用）
    _count--; // 有效元素个数-1
    
    return item;
}
```
时间复杂度： $O(1)$
### 访问队头元素（Peek）
返回队头元素，但不移除该元素，与出队的区别是不修该`_head`指针
```csharp
public T Peek()
{
    return _array[_head]; // 直接访问队头元素
}
```
时间复杂度： $O(1)$
### 元素是否存在（Contains）
判断队列中是否包含指定元素，底层通过线性查找遍历 _head 到 _tail 的有效区间，逐个对比元素
时间复杂度为 $O(n)$

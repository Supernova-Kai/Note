# 动态数组

在静态数组中提到，对于静态数组，其在初始化之后不可再修改其大小

但是在实际使用中，我们想要一种可以像数组一样高效访问，并且又可以插入删除元素以及修改其长度的数据类型

在C#中便有一种集合类型，其本身利用数组来实现，有静态数组的高效访问性能，但是相比于数组，它可以实现动态添加删除元素，那就是List

# 底层结构

首先，数组的大小是不可修改的，假设我们现在有个长度为5的int类型数组，我需要在数组末尾添加一个元素，如果实现呢？

我们可以通过新建一个长度为6的数组，将原数组的元素拷贝到新数组中，并在新数组的末尾设置添加的元素来实现

List其实就是基于这个方法，其在底层有一套扩容机制来实现上面的操作



由于List本身是泛型的，其在内存中的存储结构大致如下：

```c
T[] _array;    // T类型的数组用于存储元素
int _count;    // _array数组有效数据的长度，即list.Count属性，使用的数组长度
int _capacity; // _array数组真正的长度，可通过list.Capacity属性获取，数组真正分配空间的长度
```

# 扩容机制

1. list初始化时，_array是一个长度为0的数组
2. 当第一次添加元素时，_array会以长度为4进行初始化，即T[4]，此时添加了一个元素，_count会是1，capacity为4
3. 当不断添加元素，导致数组容量不足时（比如添加第五个元素时），触发扩容，会创建一个长度为原数组两倍的新数组，将原数组的元素拷贝到新数组中

### 注意

1. 只有添加元素导致容量不足的时候，才会进行扩容操作
2. 当删除元素导致不需要那么多空间的时候，并不会自动缩小空间（出于对性能的考虑，避免频繁的内存分配和复制操作）

# 关键操作

### 访问元素

由于其底层是一个数组，与数组访问的方式一样，通过索引可以直接获取内存地址进行访问，时间复杂度为 $O(1)$

### 查找元素

C#中List的查找方法（即Contains方法），其底层是线性查找算法，时间复杂度为 $O(n)$

### 插入元素操作

List在插入元素时，分为多种情况：

1. 在末尾添加元素，如果空间足够，在数组末尾直接赋值即可，时间复杂度为 $O(1)$
2. 在末尾添加元素，但是空间不足，需要创建新数组，并将原数组的数据拷贝到新数组，其时间复杂度为 $O(n)$
3. 在中间位置插入元素，除了可以涉及扩容之外，还需要将插入位置后面的元素不断后移，其时间复杂度为 $O(n)$

综合下来，时间复杂度取最坏的情况，List插入操作的时间复杂度为 $O(n)$

### 删除操作

List在删除元素时，分为两种情况：

1. 删除末尾元素，仅需要将_count减1即可，但是List的类型是引用对象类型，那么List实际存储的是引用对象的引用（指针），会涉及移除该引用；如果存储的是值类型，不涉及上面的过程，不论存储的是引用类型还是值类型，删除末尾元素只涉及对末尾元素的操作，其时间复杂度为 $O(1)$
2. 删除中间元素，需要将删除位置后面的元素全部前移（因为要保证数据的连续性，不能出现不连续的“**空洞**”），如果删除的是第一个元素，则是最坏的情况，时间复杂度为 $O(n)$

综合下来，时间复杂度取最坏的情况，List插入操作的时间复杂度为 $O(n)$

### 注意

删除元素不会对容量进行自动缩减，即使把List元素删完也不会，这是为了减少内存的分配次数以及大量的元素拷贝操作

   

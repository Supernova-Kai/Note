二叉搜索数，也叫二叉排序树、二叉查找树、BST（Binary Search Tree）

------

### 基本规则

1. 根节点的左子节点比根节点小
2. 根节点的右子节点比根节点大
3. 根节点的左右子节点也是二叉搜索树

![](二叉树1.jpg)

在上面的图中，根节点左边的子节点都比根节点小，根节点右边的子节点都比根节点大，那么这就是一个二叉搜索树

------

### 二叉搜索树的基本结构

```csharp
//二叉搜索树
public class BinarySearchTree
{
    //节点类
    private class TreeNode
    {
        public int Data { get; set; } //数据
        public TreeNode Left { get; set; } //左子节点
        public TreeNode Right { get; set; } //右子节点

        public TreeNode(int data)
        {
            Data = data;
            Left = null;
            Right = null;
        }
    }

    private TreeNode root; //根节点

    public BinarySearchTree()
    {
        root = null;
    }
}
```

------

### 插入数据

插入时，我们需要进行下面的操作：

1. 检查根节点是否存在，如果不存在，直接创建一个新节点放到这个位置即可
2. 如果根节点存在，需要和根节点的值进行比较
3. 如果小于根节点的值，则说明需要插入到这个根节点的左子树；如果大于根节点的值，则说明需要插入到这个根节点的右子树
4. 由于左子树和右子树可以已经存在根节点，那么我们就回到了第一步

这里就是典型的递归逻辑，我们的插入逻辑如下

```csharp
public void Insert(int data)
{
    root = InsertNode(root, data);
}

private TreeNode InsertNode(TreeNode node, int data)
{
    if (node == null) //如果当前根节点为空
    {
        node = new TreeNode(data); //初始化当前根节点
        return node;
    }

    if (data < node.Data) //比当前根节点的值小
    {
        node.Left = InsertNode(node.Left, data); //插入到左边
    }
    else if (data > node.Data) //比当前根节点的值大
    {
        node.Right = InsertNode(node.Right, data); //插入到右边
    }

    return node;
}
```

------

### 查找元素

查找元素很简单，与插入是类似的递归处理，步骤如下：

1. 与根节点进行比较，如果等于直接返回即可
2. 如果我们查找的值比根节点的值小，则去左子树里面继续寻找；如果我们查找的值比根节点的值大，则去右子树里面找
3. 不断递归，直到找到或者节点没有子树（找到底了）

代码如下

```csharp
public bool Contains(int data)
{
    return ContainsNode(root, data);
}

private bool ContainsNode(TreeNode node, int data)
{
    if (node == null)
        return false;

    if (data < node.Data)
        return ContainsNode(node.Left, data);
    else if (data > node.Data)
        return ContainsNode(node.Right, data);
    else
        return true;
}
```

------

### 删除元素

删除元素比插入要更加复杂一点，存在多种情况

**一、删除的节点没有左右子树**

比如删除图中的"0001"或"0035"，它们都没有节点，那么直接删掉即可

**二、删除的节点只有左子树**

比如删除图中的"0005"，删除之后，这里是个空位，需要填充这个位置

回到我们的规则，二叉搜索树的基本规则是“左节点的值比根节点小，右节点的值比根节点大”

由于"0005"没有右节点，只有左节点"0003"，"0003"是"0005"的左节点，是肯定比"0005"小的

那么"0003"肯定也是比"0005"的父亲，即"0010"小的

而"0003"的子树也是满足基本规则的，所以我们只需要"0003"放到"0005"之前的位置上面就可以了

**三、删除的节点只有右子树**

比如删除图中的"0023"，其实与只有左节点的情况是一样的

只有右节点，而右节点"0027"是肯定比根节点"0023"大的

那么肯定"0027"也是比"0023"的父亲"0020"大的，我们将"0027"放到"0023"原来的位置，也不会破坏基本规则

而"0027"的子树也是满足基本规则的，所以我们只需要"0027"放到"0023"之前的位置上面就可以了

**四、删除的节点左右子树都存在的情况**

比如删除图中的"0010"，那么这时候，我们选哪一个节点来代替"0010"呢

回到基本规则，“左节点的值比根节点小，右节点的值比根节点大”，那么“根节点就肯定比左子树的所有值都大，比右子树的所有值都小”

那么很简单，我们只需要找出左子树中最大的值，或者右子树中最小的值，放到被删除的位置就可以了，一般来说，习惯使用右子树中最小的值（它是右子树中的值，肯定比根节点大，那么就比左子树所有的值都大；它本身又是右子树中最小的值，那肯定比其他右子树中的节点都小）

**代码如下**

```csharp
public void Delete(int data)
{
    root = DeleteNode(root, data);
}

private TreeNode DeleteNode(TreeNode node, int data)
{
    if (node == null)
        return node;

    if (data < node.Data) //比当前根节点小,肯定在左子树
    {
        node.Left = DeleteNode(node.Left, data);
    }
    else if (data > node.Data) //比当前根节点大,肯定在右子树
    {
        node.Right = DeleteNode(node.Right, data);
    }
    else //当前删除的节点就是我们传入的数据
    {
        if (node.Left == null) //节点只有右节点
        {
            return node.Right;
        }
        else if (node.Right == null) //节点只有左节点
        {
            return node.Left;
        }

        // 节点有两个子节点：获取右子树的最小值
        node.Data = MinValue(node.Right);

        // 删除右子树的最小值
        node.Right = DeleteNode(node.Right, node.Data);
    }

    return node;
}

private int MinValue(TreeNode node)
{
    int minValue = node.Data;
    while (node.Left != null)
    {
        minValue = node.Left.Data;
        node = node.Left;
    }
    return minValue;
}
```

------

### 遍历

遍历分为四种遍历

**前序遍历（PreOrder）**

即访问顺序为：根节点->左子树->右子树

```csharp
public void PreOrder()
{
    PreOrderNode(root);
}

private void PreOrderNode(TreeNode node)
{
    if (node == null)
        return;
    Console.Write(node.Data + " ");
    PreOrderNode(node.Left);
    PreOrderNode(node.Right);
}
```

**中序遍历（InOrder）**

即访问顺序：左子树->根节点->右子树

由于左结点都比根结点小，右结点比根结点大，所以中序遍历得到的便是从小到大的序列。

```csharp
public void InOrder()
{
    InOrderNode(root);
}

private void InOrderNode(TreeNode node)
{
    if (node == null)
        return;
    InOrderNode(node.Left);
    Console.Write(node.Data + " ");
    InOrderNode(node.Right);
}
```

**后序遍历（PostOrder）**

即访问顺序：左子树->根节点->右子树

```csharp
public void PostOrder()
{
    PostOrderNode(root);
    Console.WriteLine();
}

private void PostOrderNode(TreeNode node)
{
    if (node == null)
        return;
    PostOrderNode(node.Left);
    PostOrderNode(node.Right);
    Console.Write(node.Data + " ");
}
```

**层序遍历（LevelOrder）**

先访问某一层再访问下一层

```csharp
public void LevelOrder()
{
    if (root == null)
        return; // 空树直接返回

    Queue<TreeNode> queue = new Queue<TreeNode>();
    queue.Enqueue(root); // 根节点入队

    while (queue.Count > 0) // 队列不为空时循环
    {
        TreeNode current = queue.Dequeue(); // 取出队首节点
        Console.Write(current.Data + " "); // 访问该节点

        // 将当前节点的左子节点入队（如果存在）
        if (current.Left != null)
            queue.Enqueue(current.Left);

        // 将当前节点的右子节点入队（如果存在）
        if (current.Right != null)
            queue.Enqueue(current.Right);
    }
    Console.WriteLine();
}
```

------

[Binary Search Tree](http://link.zhihu.com/?target=https%3A//www.cs.usfca.edu/~galles/visualization/BST.html)这个网站可以很好的可视化查看二叉搜索树的结构以及用动画演示各种操作
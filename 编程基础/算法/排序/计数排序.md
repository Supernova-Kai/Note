# 计数排序
### 思路
计数排序的思路大致如下：

1. 统计集合中每一个元素出现的次数
2. 按元素从大到小的顺序输出对应次数即可

### 示例
假设我们有一个数组如下：
```csharp
int[] array = new int[6]{ 5, 3, 7, 2, 2, 1 };
```
那么我们可以先建立一个缓存，存储该数组所有元素出现的次数，可以得到如下的元素与次数的关系：
```csharp
元素 - 次数
1 - 1
2 - 2
3 - 1
5 - 1
7 - 1
```
我们只需要按照元素从小到大的顺序输出即可，对于出现了多次的元素（比如2），出现了多少次，输出多少次即可
# 代码示例
```csharp
/// <summary>
/// 计数排序
/// </summary>
/// <param name="array">原数组</param>
public int[] CountingSort(int[] array)
{
    if (array == null || array.Length <= 1)
        return array;
        
    // 1.第一次遍历原数组，找到最大值和最小值
    int min = array[0];
    int max = array[0];
    for (int i = 0; i < array.Length; i++)
    {
        if (array[i] < min)
            min = array[i];
            
        if (array[i] > max)
            max = array[i];
    }
        
    // 2.建立一个缓存，存储每一个元素出现的次数
    int[] cache = new int[max - min + 1]; // 最大值是5，最小值是2，如果中间值都存在，一共有2 3 4 5四个数，需要max - min + 1长度的数组来缓存
        
    // 3.第二次遍历原数组，统计元素出现次数
    for (int j = 0; j < array.Length; j++)
    {
        int value = array[j]; // 元素值
        int key = value - min; // value相对于min的偏移量作为下标
        cache[key]++; // 计数
    }
        
    // 4.遍历缓存，按顺序和次数输出元素
    int index = 0;
    for (int k = 0; k < cache.Length; k++)
    {
        while (cache[k] > 0) // 有计数，说明该元素出现过，出现多少次就输出多少次
        {
            array[index] = min + k; // k是相对于min的偏移量，记得复原真正的数据
            cache[k]--; // 计数--
            index++;
        }
    }

    return array;
}
```
### 注意事项

1. 为了节省缓存数组的空间，可以将元素值`value`减去`mi`n作为缓存数组的`key`（也就是相对于最小值min偏移了多少个单位）
2. 最大值`max`和最小值`min`之间，如果其中间值都存在，一共有`max - min + 1`个数
# 复杂度分析
### 时间复杂度
下面我们称数组长度为`n`，数据范围为`k`（数据范围指的是最小值和最大值的差值+1）

1. 对于第一个`for`循环，其遍历原数组来找出最大值和最小值，时间复杂度为 $O(n)$
2. 对于第二个`for`循环，其遍历原数组来进行计数，时间复杂度为 $O(n)$
3. 对于第三个`for`循环，其遍历缓存来输出集合，缓存的长度为数据范围`k`，其时间复杂度为 $O(k)$

综上，计数排序的时间复杂度为： $O(3n+k)$，在时间复杂度中，只在乎数量级，所以其时间复杂度为： $O(n)$
### 空间复杂度
建立了一个长度为`k`的缓存，空间复杂度为： $O(k)$




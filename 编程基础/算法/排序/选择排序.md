# 选择排序
### 思路
思路类似这样的逻辑：

有5个学生排成一队，第一次选出最矮的学生和第一个学生交换位置

第二次在剩下的4个学生中选出最矮的（也就是第二矮的学生），并与第二个学生交换位置

直到最后一名学生

### 具体过程
1. 将集合分为未排序部分和已排序部分（第一次迭代时，未排序部分就是整个集合，已排序部分为空）
2. 当前外层循环控制迭代，假定当前索引i是最小的值，并记录当前最小数的索引，即`minIndex = i`
3. 内层循环遍历索引`i`之后的所有元素，遇到比索引`i`更小的数，就更新`minIndex`
4. 当遍历结束后，`minIndex`如果和`i`不相等，则交换两个数
5. 重复上诉过程，直到未排序部分为空

# 代码示例
```csharp
public void SelectionSort(int[] array)
{
    for (int i = 0; i < array.Length - 1; i++) // i可以理解为“索引i需要一个正确的值”
    {
        int minIndex = i; //先假定索引i是最小的

        //下面的循环用于在未排序部分中选出最小的元素
        for (int j = i + 1; j < array.Length; j++) // 未排序部分就是索引i之后的部分
        {
            if (array[j] < array[minIndex])
            {
                minIndex = j; // 找到更小的元素就更新索引
            }
        }

        if (minIndex != i)
        {
            // 交换元素
            int temp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = temp;
        }
    }
}
```
# 复杂度分析

- 时间复杂度： $O(n^2)$
- 空间复杂度：未开辟新空间，为 $O(1)$

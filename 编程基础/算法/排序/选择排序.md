### 基本原理

1. 通过循环控制排序的轮数
2. 每一轮找出未排序部分最小的数，并将其与未排序部分第一个元素交换（也就是未排序部分和已排序部分的分界点）

例如，我们的集合长度为n，那么我们就需要n-1轮（因为也是交换两个元素，只需要n-1轮），当第一轮的时候，我们需要在未排序部分找出最小的数，并将它与未排序部分的第一个元素交换（第一轮因为没有已排序部分，就是和集合第一个元素交换），此时已排序部分有一个元素，未排序部分剩下n-1个元素；当第二轮的时候，我们需要在未排序部分继续找出最小的元素，将它插入到已排序部分的末尾（也就是和未排序部分的第一个元素交换）

------

时间复杂度：$O(n^2)$

相比于冒泡排序，内层循环只有一次交换的步骤，性能相比于冒泡排序更高

空间复杂度：不开辟新空间，为$O(1)$

------

### 代码

```csharp
public static void SelectionSort(int[] array)
{
    for (int i = 0; i < array.Length - 1; i++) // i可以理解为“索引i需要一个正确的值”
    {
        int minIndex = i; //先假定索引i是最小的

        //下面的循环用于在未排序部分中“选择”出最小的元素
        for (int j = i + 1; j < array.Length; j++) //未排序部分就是索引i之后的部分
        {
            if (array[j] < array[minIndex])
            {
                minIndex = j; //找到更小的元素就更新索引
            }
        }

        if (minIndex != i)
        {
            // 交换元素
            int temp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = temp;
        }
    }
}
```
# 之前的写法
```csharp
public void BubbleSort(int[] array)
{
    for (int i = 0; i < array.Length - 1; i++)
    {
        for (int j = 0; j < array.Length - 1 - i; j++)
        {
            if (array[j + 1] < array[j])
            {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
            }
        }
    }
}
```
# 问题
我们来看看下面这个案例：

有一个集合的长度是5，只有前两个元素的顺序是反的，也就是下面这样：
```csharp
int[] array = new int[5]{ 2,1,3,4,5 }
```
那么当我第一轮排序结束时，2和1就会交换位置，此时集合已经是完全有序的了，就没有必须走后面几轮了
# 优化

优化方法很简单，**如果有某一轮，我们内层循环没有进行过任何一次交换**，那么就说明，集合本身已经是完全有序的了，我们只需要提前终止外层循环便可以了
```csharp
public void BubbleSort(int[] array)
{
    for (int i = 0; i < array.Length - 1; i++)
    {
        bool swapped = false;  // 标记本轮是否发生过交换
        for (int j = 0; j < array.Length - 1 - i; j++)
        {
            if (array[j + 1] < array[j])
            {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
                swapped = true;  // 发生了交换，标记改为 true
            }
        }

        if (!swapped)  // 如果本轮没有交换，说明数组已经有序，提前结束
        {
            break;
        }
    }
}
```

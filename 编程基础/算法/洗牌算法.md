# 问题

现在我有一副扑克牌，如何使用一个算法将其打乱顺序，需要保证扑克牌最终出现的每一种序列的概率都是均等的

# 抽牌算法

### 原理

该算法也叫做`Fisher-Yates Shuffle`算法，其最初版本是一种抽牌的做法，通过不断从原始集合中随机选取元素，并添加到新集合B中来实现，具体过程如下：

1. 假设我们的原始集合叫A，从A中随机取一个元素（抽一张牌出来）
2. 将该元素添加到新集合B中，并将其从A中删除
3. 重复上诉过程，直到集合A中没有剩余的元素

### 代码

```csharp
public List<int> Shuffle(List<int> list)
{
    Random random = new Random();
    List<int> result = new List<int>();
    while (list.Count > 0) // 原集合中还有剩余元素
    {
        int randomIndex = random.Next(0, list.Count); // 当前长度内取一个随机索引
        result.Add(list[randomIndex]); // 添加到新的集合
        list.RemoveAt(randomIndex); // 从原集合中移除
    }
    return result;
}
```

### 概率均等的原因

为什么这一种算法中，最终得到的任何一种序列的概率是均等的呢？

1. 首先，假设我们的原集合有n个元素
2. 当我们第一次取随机元素时，任何一个元素被选中的概率是 $\frac {1}{n}$
3. 当我们第二次取元素时，需要在剩下的`n-1`个元素中取一个元素出来，每一个元素被选中的概率是一个**条件概率**，即，”**在第一次中没有被选中的概率 * 在第二次被选中的概率**“，在第一次中没有被选中的概率是 $\frac {n-1}{n}$ ，在第二次中被选中的概率是 $\frac {1}{n-1}$，那么总概率就是 $\frac {n-1}{n} \times \frac {1}{n-1} = \frac {1}{n}$
4. 同理，不论是在第几轮取元素，其概率都是 一样的，那么便确保了最终的序列的概率都是一样的

# 原地洗牌版本

在上面的原始版本算法中，其存在一个小问题，该算法通过从原集合中取出一个元素，添加到新集合的方式来实现打乱顺序，其涉及到列表的添加、删除等操作，在面对大规模数据的时候，性能不太理想，于是有了原地洗牌版本

所谓原地，就是不建立新集合，在原集合本身内便可完成洗牌操作

### 代码

```c#
public void Shuffle(List<int> list)
{
    Random random = new Random();
    for (int i = 0; i < list.Count; i++)
    {
        int randomIndex = random.Next(i, list.Count);
        int temp = list[randomIndex];
        list[randomIndex] = list[i];
        list[i] = temp;
    }
}
```




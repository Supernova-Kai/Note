# 问题

有一个集合，检查集合内是否有重复元素。

# 嵌套循环法

### 思路

假设集合的长度是n，对于索引为x的元素，我们只需要检查其后面的元素是否有和其相等的即可。

### 代码

```c#
public bool ContainsDuplicate(int[] num)
{
    for (int i = 0; i < num.Length - 1; i++) // 最后一个元素没有后面的元素，不需要进行判断
    {
        for (int j = i + 1; j < num.Length; j++) //每个元素只需要和它后面的元素比较
        {
            if (num[i] == num[j])
            {
                return true;
            }
        }
    }
    return false;
}
```

### 时间复杂度

对于上诉的代码，其真正执行的是内存循环体内$if$语句内的逻辑，我们分析的便是，输入值$nums$的长度与$if$语句内的逻辑执行次数的函数关系。

假设我们的集合长度为n，那么外层循环需要执行n次，外层循环的$i$从$0$到$n-2$，由于对于每个元素需要遍历检查其后面的元素，那么就有：

1. 当$i=0$时，需要检查$1$到$n-1$的所有元素，共$n-1$次
2. 当$i=1$时，需要检查$2$到$n-1$的所有元素，共$n-2$次
3. ...
4. 当$i=n-3$时，需要检查$n-2$到$n-1$的所有元素，共$2$次
5. 当$i=n-2$时，需要检查$n-2$到$n-1$的所有元素，共$1$次

这是一个等差数列，可以得到总的为：$\frac {n \times (n-2)}{2}$，忽略低价项，其时间复杂度为 $O(n^2)$。

### 空间复杂度

未开辟新空间，为 $O(1)$。

# 哈希缓存法

显然，上面的嵌套循环法性能说较差的，下面我们对其进行优化。

### 思路

C#中，哈希集合的访问操作，时间复杂度为 $O(1)$，那么我们可以建立一个哈希集合的缓存，在遍历的过程中，先检查元素是否已经在缓存中，如果已存在就说明之前出现过了，也就是重复了；如果没有在缓存中，将其添加到缓存中即可。

这是一种代码优化方法，**用空间换取时间**。

### 代码

```c#
public bool ContainsDuplicate2(int[] num)
{ 
    HashSet<int> cache = new HashSet<int>(); // 缓存
    for (int i = 0; i < num.Length; i++)
    {
        if (cache.Contains(num[i])) // 已经在缓存中存在了，那么便是重复了
            return true;

        cache.Add(num[i]);
    }
    return false;
}
```

### 时间复杂度

由于只有一层循环，时间复杂度为 $O(n)$。

### 空间复杂度

最坏的情况下，即没有重复元素，需要缓存整个原数组，空间复杂度为 $O(n)$。


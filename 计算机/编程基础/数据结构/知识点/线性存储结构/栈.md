# 栈（Stack）
栈是一种遵循**先进后出，后进先出**（LIFO）的线性存储数据结构
### 特性

- **只能**在栈顶进行添加元素（入栈）、删除元素（出栈）和访问元素（Peek）
- 不支持随机访问元素，也就是不能像数组那样使用下标访问任意位置的元素，必须通过出栈操作逐步移除元素才能访问在中间的元素

# 底层原理
通过上面的描述，我们可以发现栈其实就是限制了部分操作的动态数组，并且只能在栈顶位置才能进行各项操作
所以，我们只需要在动态数组的基础上使用一个变量记录栈顶位置即可

C#中的Stack也是泛型的，其在内存中的存储结构大致如下：
```csharp
T[] _array;    // T类型的数组用于存储元素
int _count;    // _array数组有效数据的长度，即list.Count属性，使用的数组长度
int _capacity; // _array数组真正的长度，可通过list.Capacity属性获取，数组真正分配空间的长度
int _top; // 标记栈顶位置
```
我们只需要在入栈、出栈时维护这个栈顶位置的变量即可
# 关键操作
### 入栈（Push）
入栈，即向栈顶位置添加一个元素，由于标记了栈顶位置，入栈时只需要对栈顶位置进行赋值，并更新栈顶位置即可，其逻辑类似下面的代码：
```csharp
public void Push(T value)
{
    _array[_top] = value;
    _top++;
}
```
注意，当数组容量不足时，栈与List一样也会涉及扩容，所以入栈的时间复杂度在不涉及扩容情况下是 $O(1)$，在涉及扩容的情况下是 $O(n)$
### 出栈（Pop）
出栈，即从栈顶位置移除并返回该元素，其逻辑类似下面的代码：
```csharp
public T Pop()
{
    T item = _array[_top];
    _top--;
    return item;
}
```
由于栈只能从栈顶位置删除元素，所以出栈只涉及对栈顶元素的操作，其时间复杂度为 $O(1)$
与List类似，为了减少频繁的分配空间及元素拷贝操作，出栈不会自动缩小数组的空间
### 访问栈顶元素（Peek）
返回栈顶元素，与Pop的区别在于，仅返回元素不出栈，相当于访问数组在栈顶位置下标的元素，其时间复杂度为 $O(1)$
### 元素是否存在（Contains）
判断某个元素是否存在栈中，其底层实现原理是基于线性查找的算法，时间复杂度为 $O(n)$

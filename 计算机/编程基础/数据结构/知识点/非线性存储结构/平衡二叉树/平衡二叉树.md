# 平衡二叉树
### 目的
在之前的笔记中提到，普通的二叉搜索树在某些极端的情况下（插入完全有序的数据）会退化成链表，导致操作的时间复杂度退化成 $O(n)$，而平衡二叉树的目的便是解决此类问题
### 定义
平衡二叉树（AVL树），是一种**自平衡的二叉搜索树**，它在二叉搜索树“左小右大”的基础上，新增了“**高度平衡**”的约束

### 基本规则
平衡二叉树在二叉搜索树的约束条件上，多一个“**高度平衡**”的约束条件，即：

- 高度平衡：任意节点的左、右子树的高度差（平衡因子）的绝对值**不能超过1**

# 概念
在讲解AVL树之前，先明确几个概念

### 高度
某个节点的高度 = 从该节点到其**最远叶子节点**的路径长度

注：对于空节点和叶子节点的高度，有两种不同的定义：

1. 第一种，空节点高度定义为0，叶子节点的高度定义为1
2. 第二种，空节点高度定义为-1，叶子节点的高度定义为0

后文均采用第二种，**空节点高度定位为-1，叶子节点的高度定义为0**

```plaintext
    5        // 5的最远叶子节点是2（或6），路径为 5->3->2，路径长度为2，所以5的高度为2
   / \
  3   7      // 3的最远叶子节点是2，路径为 3->2，路径长度为1，所以3的高度为1；7同理
 /   /
2   6        // 2和6均是叶子节点，高度为0
```

除了可以通过数最远路径长度来得到高度之外，还可以通过以下公式获取：

$$
height = max(heightLeft,heightRight) + 1
$$

其中`heightLeft`代表左子节点的高度，`heightRight`代表右子节点的高度，即：“**某个节点的高度等于其子节点高度中的较大值+1**”

### 平衡因子（BF）
平衡因子 = 左子节点高度 - 右子节点高度

还是以上面这个树为例：

```plaintext
    5        // 5的左子节点高度为1，右子节点高度为1，BF = 1 - 1 = 0
   / \
  3   7      // 3和7，左子节点高度为0，右子节点不存在，高度为-1，BF = 0 - (-1) = 1
 /   /
2   6        // 2和6的左右子节点都是空节点，空节点高度为-1，所以2和6的BF= (-1) - (-1) = 0
```

# 四种失衡情况

### 左左失衡（LL）
**特征：**

失衡节点的左子树的高度过高，失衡节点的左子树是导致高度失衡的原因（失衡节点BF = 2，失衡节点的左子节点BF = 1）
```plaintext
    7
   /
  5
 /
3
```

**修复方式：**

对失衡节点（7）进行**右旋**操作
```plaintext
    7
   /
  5      --->        5
 /                 /   \
3                 3     7
```

### 右右失衡（RR）
**特征：**

失衡节点的右子树高度过高，失衡节点的右子树是导致高度失衡的原因（失衡节点BF = -2，失衡节点的右子节点BF = -1）
```plaintext
3
 \
  5
   \
    7
```
**修复方式：**

对失衡节点（3）进行**左旋**操作
```plaintext
3
 \
  5          --->       5
   \                  /   \
    7                3     7
```

### 左右失衡（LR）
**特征：**

失衡节点的左子树高度过高，失衡节点的右子树是导致高度失衡的原因（失衡节点BF = 2，失衡节点的左子节点BF = -1）
```plaintext
    7
   /
  5
   \
    6
```

**修复方式：**
先对失衡节点的左子节点（5）进行**左旋**，这样就转化为了**LL失衡**，再对失衡节点（7）进行**右旋**
```plaintext
    7                7
   /                /
  5      --->      6        --->         6
   \              /                     /  \
    6            5                     5    7
```

### 右左失衡（RL）
**特征：**

失衡节点的右子树高度过高，失衡节点的左子树是导致高度失衡的原因（失衡节点BF = -2，失衡节点的右子节点BF = 1）
```plaintext
3
 \
  7
 /
5
```

**修复方式：**
先对失衡节点右子节点（7）进行**右旋**，这样就转化为了**RR失衡**，再对失衡节点（3）进行**左旋**
```plaintext
3             3
 \             \
  7    --->     5      --->         5
 /               \                /   \
5                 7              3     7
```

### 总结
 - `LL`和`RR`失衡，只需要一步操作便可恢复平衡
 - `LR`和`RL`失衡，先将其转化为`LL`或者`RR`失衡，再按照`LL`和`RR`的方式处理即可

# 旋转操作
### 左旋

```plaintext
a
 \
  b
   \
    c
```

这里用形象的说法来说，我们要让上面的树变成“平衡”的，那么需要将`a`沉下去，`b`提起来（也就是把`a`放到`b`的左子节点），那么这里有个问题，如果`b`本身有左子节点，又怎么办呢？

我们可以发现，`a`原本是有右子节点的（也就是`b`），但是`a`沉下去之后，`a`的右子节点的位置空出来了，我们可以，而`b`的左子节点，是处于`a`的右子树中的，也就是一定比`a`大的，那么它是可以作为`a`的右子节点的

**具体步骤如下：**

1. 将失衡节点的右子节点设为“新根”
2. 原失衡节点降级为“新根”的左子节点
3. 如果“新根”原本是有左子节点的，将其设为原来失衡节点的右子节点

**代码如下：**
```csharp
// 左旋操作（node为失衡节点）
private TreeNode LeftRotate(TreeNode node)
{
    TreeNode newRoot = node.Right; // 新根：失衡节点的右子节点
    TreeNode temp = newRoot.Left; // 暂存新根的左子节点

    // 调整父子关系
    newRoot.Left = node; // 原失衡节点变为新根的左子节点
    node.Right = temp; // 暂存的节点转为原失衡节点的右子节点

    return newRoot; // 返回新根，替换原失衡节点的位置
}
```

### 右旋
与左旋逻辑类似，具体步骤如下：

1. 将失衡节点的左子节点设为 “新根”
2. 原失衡节点降级为“新根”的右子节点
3. 若“新根”原本有右子节点，将其转为原失衡节点的左子节点

```csharp
// 右旋操作（node为失衡节点）
private TreeNode RotateRight(TreeNode node)
{
    TreeNode newRoot = node.Left; // 新根：失衡节点的左子节点
    TreeNode temp = newRoot.Right; // 暂存新根的右子节点

    // 调整父子关系
    newRoot.Right = node; // 原失衡节点变为新根的右子节点
    node.Left = temp; // 暂存的节点转为原失衡节点的左子节点

    return newRoot; // 返回新根，替换原失衡节点的位置
}
```

# 补充
在代码层面上，AVL树除了在二叉搜索树的基础上新增了左旋、右旋操作之外，还需要在节点的数据结构上新增高度属性，以及获取节点高度、计算节点平衡因子、并在插入、删除步骤之后完成更新节点高度、计算平衡因子，并根据平衡因子处理四种不同的失衡情况，这里不再赘述，可以移步Code目录下的对应文件查看完整代码
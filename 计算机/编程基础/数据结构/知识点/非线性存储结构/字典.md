# 字典
字典是一种以键值对（Key-Value）形式存储数据的数据结构，其核心优势在于实现了**O(1)时间复杂度级别的访问、插入和删除效率**，其底层依赖哈希表实现，与线性结构的数据结构有本质的区别

对于字典这一类型的数据结构，有各种不同形式的，比如有：`Key`和`Value`可以是任何类型的`HashTable`、只关心`Value`不关心`Key`的`HashSet`等等，下面我们以`Dictionary<TKey, TValue>`为例讲解字典的底层原理

# 哈希值
在讲解字典底层原理之前，我们先认识一个概念，哈希值

在`C#`中，绝大部分的数据类型，都直接或间接的拥有`GetHashCode`方法，`HashCode`的本质是“**将任意类型、任意内容的数据，映射到一个整数**”

### 特性

- 相同的数据必须返回相同的`HashCode`（确定性）
- 不同的数据尽可能返回不同的`HashCode`

举个例子，对于一个`string`类型的字符串，假设它最开始的值是“Hello World”，只要我不修改它，其哈希值是永远不变的，这就是确定性；
但是一旦我对其进行了哪怕一点点的修改，哈希函数的设计会尽可能让哈希值不同（哈希函数的设计不能做到完全不同，可能会是一样的）

# 字典底层原理
字典在内存中存储的结构大致如下：
```csharp
struct Entry
{
    int HashCode;  // 哈希值
    int Next;      // 下一个索引
    TKey Key;      // 键
    TValue Value;  // 值
}

int[] _buckets;    // 桶数组
Entry[] _entries;  // 条目数组
int _count;        // 有效键值对数量
```
我们先认为，数据都是以`Entry`这个结构体的结构存储在条目数组`_entries`中的（暂时不看`Next`字段），接下来我们先讲解一下字典中最重要的两个概念，**桶数组**和**条目数组**

### 桶数组和条目数组
在前面提到，**条目数组才是真正存储数据的地方**，那么对于每一个数据，其都有一个在条目数组中的下标，我们要实现 $O(1)$级别的操作，就必须想办法把这个下标和`Key`映射上，我们便利用桶数组来实现这个映射

那么是怎么映射的呢？

假设我们现在需要存储一对键值对`<TKey, TValue>`，大致的过程如下：

1. 第一步，会取出`Key`的哈希值，也就是`int hashCode = Key.GetHashCode();`
2. 第二步，由于哈希值不一定在我们的桶数组长度范围内，我们需要把这个哈希值映射到数组范围内，其实很简单，将哈希值与桶数组的长度取余即可，也就是`int bucketIndex = hashCode % _buckets.Length`
3. 第三步，将实际的数据，以`Entry`结构体的结构，存储在条目数组中，这里存储的时候，数据存储在第几个，以及条目数组中的顺序没有意义，向条目数组的末尾添加即可，也就是`_entries[_count] = value`，
也就是我们的数据存到了条目数组中`_count`下标的位置
4. 第四步，建立映射关系，数据存在了条目数组的`_count`下标处，通过`Key`生成了桶数组中唯一的索引位置`bucketIndex`，那么这个映射关系很好建立，即：`_buckets[bucketIndex] = _count`

注意，由于桶数组存储的是`Key`与条目数组的映射关系，所以桶数组初始化时，需要将元素全部初始化为`-1`，以视为没有映射

总结一下，其步骤大概是这样：
```csharp
public void Add(TKey key, TValue value)
{
    // 1. 获取哈希值
    int hashCode = key.GetHashCode();

    // 2. 哈希值转为桶数组索引
    int bucketIndex = hashCode % _buckets.Length;

    // 3. 条目数组赋值(我们先不管Next)
    _entries[_count].HashCode = hashCode;
    _entries[_count].Key = key;
    _entries[_count].Value = value;

    // 4. 桶数组映射这个索引
    _buckets[bucketIndex] = _count;

    _count++;
}
```
那么我们需要通过`Key`找到对于的`Value`，其大概流程便是如下这样：
`Key -> 获取哈希值（hashCode = key.GetHashCode()） -> 获取桶索引（bucketIndex = hashCode % _buckets.Length） -> 去桶数组该索引获取条目数组中的下标（entryIndex = _buckets[bucketIndex]） -> 条目数组获取Value（_entries[entryIndex]）`

这只是一个简单的示例，并不完美，甚至还有会严重的问题，下面我们讲解其问题所在
# 哈希冲突
### 问题
上面的流程看似已经符合我们的需求了，但是这里有一个很严重的问题：

1. 首先，由于哈希函数的设计问题，无法做到不同的值一定是不一样的哈希值，**也就是不同的`Key`可能会得到相同的哈希码**
2. 其次，由于桶数组索引是通过哈希值对桶数组长度取模得到的，对于不同的哈希值，其**取模后可能会得到相同的桶索引**

上面的这两种情况，便是常说的“**哈希冲突**”，对于解决冲突，常见的一种做法叫做“**链地址法**”，下面我们讲解其原理
### 链地址法
在前面的讲解中，我们忽略了`Entry`结构体中的一个字段`Next`，其代表的便是该元素的下一个元素的索引，也就是类似链表的结构

假设有一个`Dictionary<int, char>`来存数字与字母的对应关系，我们看看`Next`是如何解决哈希冲突的：

1、初始化字典的桶数组和条目数组，我们假设初始化长度是`4`，并且将桶数组标记为都没有映射，也就是`_buckets`长度为`4`，并且值均为`-1`，`_entries`长度也为`4`，此时字典的存储结构如下：
```csharp
_buckets[0] = -1
_buckets[1] = -1
_buckets[2] = -1
_buckets[3] = -1

_entries[0] = null
_entries[1] = null
_entries[2] = null
_entries[3] = null

_count = 0
```

2、添加第一对键值对，`<1, 'a'>`，我们假设`1`对应的桶索引就是`1`，也就是`bucketIndex = 1`，此时`_count = 0`，那么添加完成后，`_buckets[1] = 0`（桶数组的索引`1`指向条目数组的索引`0`），`_entries[0] = a对应的Entry结构（后文以entryA代替）`
，完成后如下：
```csharp
_buckets[0] = -1
_buckets[1] = 0
_buckets[2] = -1
_buckets[3] = -1

_entries[0] = entryA（entryA.Next = -1，-1代表是链表最后一个）
_entries[1] = null
_entries[2] = null
_entries[3] = null

_count = 1
```

3、此时，我们添加第二队键值对，`<2, 'b'>`，假设此时`2`对应的桶索引还是`1`，也就是`bucketIndex`还是等于`1`，我们发现`_buckets[1] = 0`（也就是桶索引`1`已经指向条目数组的索引`0`了），于是我们继续找到这个条目，也就是`entryA`，此时我们需要做下面三件事：

1. 将`b`放到条目数组中的有效位置，由于前面提到，条目数组中数据的顺序和位置实际上无意义，当前`_count = 1`，也就是`_entries[1]`是当前可以使用的位置，我们将`b`对应的Entry结构（后文称`entryB`）放到`_entries[1]`
2. 把之前桶数组记录的索引放到`entryB`的`Next`，也就是`entryB.Next = 0`
3. 将桶数组记录的索引更新为现在的`_count`，也就是`_buckets[1] = 1`
4. `_count++`

上诉的过程完成后，结构如下：
```csharp
_buckets[0] = -1
_buckets[1] = 1
_buckets[2] = -1
_buckets[3] = -1

_entries[0] = entryA（entryA.Next = -1）
_entries[1] = entryB（entryB.Next = 0，即entryB指向条目数组中的索引0）
_entries[2] = null
_entries[3] = null

_count = 2
```

4、此时，我们添加第三队键值对，`<3, 'c'>`，假设此时`3`对应的桶索引还是`1`，那么重复上面的过程，将`_entries[2] = entryC`，`entryC.Next`指向`entryB`，`_buckets[1]`指向现在的`_count`，可得到结果如下：
```csharp
_buckets[0] = -1
_buckets[1] = 2
_buckets[2] = -1
_buckets[3] = -1

_entries[0] = entryA（entryA.Next = -1, -1代表是链表最后一个）
_entries[1] = entryB（entryB.Next = 0，即entryB指向条目数组中的索引0）
_entries[2] = entryC（entryC.Next = 1，即entryC指向条目数组中的索引1）
_entries[3] = null

_count = 3
```

那么，对于冲突的`Key`，我们在条目数组中构建了一个链表，这便是**链地址法**
# 扩容机制
不论是桶数组还是条目数组，其空间也涉及到不足需要扩容的情况，但是与`List`、`Stack`等不同，其扩容机制是依赖于一种称之为负载因子的来实现的

当字典的有效元素数量（`_count`）与桶数组长度（_buckets.Length）的比值（即：负载因子）超过阈值（C#默认为0.72）时，触发扩容，目的是减少哈希冲突，维持 $O(1)$的效率，其扩容步骤如下：

1. 创建新的桶数组和条目数组，长度为原容量的 2 倍（保持 2 的幂次）
2. 重新计算所有现有键的哈希码，映射到新的桶数组中
3. 将原条目数组的键值对拷贝到新数组，完成扩容

# 补充
这里只是大概讲解了字典的底层存储结构、哈希冲突的解决方法、扩容机制，仅于学习字典的**基本**原理，因为在实际中，字典是更加复杂的

首先，不同的语言对于哈希冲突有不同的解决方案，部分语言会使用开放寻址法（不使用链表，直接迭代找条目数组中下一个有效的位置），而对于使用链地址法的语言，
如果在同一个桶索引冲突元素过多，会导致链表过长，其效率会退化为 $O(n)$，部分语言采用了红黑树进行优化

其次，在我们的示例中，每一次添加元素，都会走一次取哈希值，计算桶索引的流程，效率是较低的，部分语言会在删除元素时，用一个空闲链表记录当前条目数组中空闲的位置，添加时，先优先从空闲链表中取，用于提示效率

以上部分，都不那么“基础”，这里不过多赘述





















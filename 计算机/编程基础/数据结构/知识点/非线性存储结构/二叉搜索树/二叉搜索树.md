# 二叉搜索树
### 定义
二叉搜索树（Binary Search Tree，简称 BST）是一种基于二叉树的数据结构，其底层依赖“**左小右大**”的有序性规则构建

二叉搜索树的最大优势在于高效的查找、插入以及删除操作，时间复杂度为 $O(log_2 n)$（理想情况下）
### 基本规则

1. 左节点的值必须比当前节点**小**
2. 右节点的值必须比当前节点**大**
3. 左、右子树本身也必须是二叉搜索树（**递归约束**）

下面这个树就是符合上面条件的二叉搜索树：

```plaintext
        5
       / \
      3   7
     / \ / \
    2  4 6  8
```

### 概念
以上面示例中的二叉搜索树为例，先认识几个概念

- 根节点：即树的**最顶层**节点，其没有父节点（示例中的`5`）
- 叶子节点：左、右节点均为空的节点，即没有子节点的节点（示例中的`2`、`4`、`6`、`8`均是叶子节点）
- 父节点/子节点：节点A包含节点B的引用，那么A就是B的父节点，B就是A的子节点
- 深度：从根节点到当前节点的路径长度
- 高度：从当前节点到最远的叶子节点的路径长度

# 基本结构
二叉搜索树的基本结构如下：
```csharp
/// <summary>
/// 二叉搜索树
/// </summary>
public class BinarySearchTree
{
    /// <summary>
    /// 节点结构
    /// </summary>
    private class TreeNode
    {
        public int Value; // 数据
        public TreeNode Left; // 左子节点
        public TreeNode Right; // 右子节点
        
        public TreeNode(int value)
        {
            Value = value;
            Left = null;
            Right = null;
        }
    }
    
    private TreeNode _root; // 二叉搜索树的根节点

    public BinarySearchTree()
    {
        _root = null;
    }
}
```
二叉树的所有操作都是从根节点开始进行的，所以二叉搜索树会存下根节点
# 关键操作
### 插入元素
插入元素时，我们只需要从根节点开始按如下步骤即可：

1. 检查树是否为空（即`_root`是否为`null`），如果树为空，则创建新节点作为根节点即可
2. 若树不为空，当前节点便是根节点（后文称当前节点为`currentNode`），比较插入值与`currentNode`的值，若小于，则说明插入值应该放到`currentNode`的左子树；若大于，则说明插入值应该放到`currentNode`的右子树
3. 更新`currentNode`，重复上诉过程即可，直到找到空的位置

代码示例：
```csharp
public void Insert(int value)
{
    root = InsertNode(root, value);
}

private TreeNode InsertNode(TreeNode node, int value)
{
    if (node == null) // 找到了空的节点，即插入位置
    {
        node = new TreeNode(value); // 初始化一个节点
        return node;
    }

    if (value < node.Value) // 插入值比当前节点值小，去左子树
    {
        node.Left = InsertNode(node.Left, value); // 递归node.Left
    }
    else if (value > node.Value) // 插入值比当前节点值大，去右子树
    {
        node.Right = InsertNode(node.Right, value); // 递归node.Right
    }

    return node;
}
```

### 删除元素
删除元素相较于插入元素，要复杂一些，我们需要在删除节点之后，仍然保证二叉搜索树，**左小右大**的基本规则

根据删除节点的子节点的个数，分为以下三种情况：

**一、删除的节点有0个子节点**
```plaintext
  a
 / \
b   c
```
以上面这个树为例子，`b`和`c`的子节点个数均是`0`，也就是没有子节点，都是叶子节点，那么删除操作很简单，直接将删除节点的父节点对应的引用设为`null`即可

比如，我要删除节点`b`，那么我只需要将`b`在其的父节点（也就是`a`）的引用设为`null`就行了，即`a.Left = null`

**二、删除的节点有1个子节点**
```plaintext
    c
   /  \
  b    d
 /      \
a        e
```
以上面的树为例，`b`和`d`的子节点个数均是`1`，有一个子节点，如果我们要删除`b`或者`d`，面临一个问题，删掉之后，它们的子树怎么办？

牢记一点，我们需要在删除后，仍然保持二叉树**左小右大**的基本规则

首先，在删除前，不论`a`是在`b`的左边还是右边，`a`都是处于`c`的左子树，那么说明`a`一定是比`c`小的，也就是说`a`是符合作`c`的左子节点的条件的

那么，这种情况下的删除逻辑就很简单了，只需要将删除节点的父节对应的引用改为删除节点的子节点即可

比如，我要删除节点`b`，那么我只需要将`b`在其父节点（也就是`c`）的引用，改为`b`的子节点即可，即`c.Left = b.Left`

**三、删除的节点有2个子节点**
```plaintext
     d
    /
   c
 /  \
a    b
    /  
   e
```
以上面的树为例子，此时我要删除节点`c`，但是它有两个子节点，如何处理呢？

对于这种情况，其核心思路是：“**找到该删除节点右子树中最小的节点（或者左子树中最大的节点）来替换掉删除的节点**”

还是以上图为例，我们要删掉节点`c`，那么我们先找到`c`的右子树中最小的节点，也就是`e`，我们看看`e`的情况

1. 由于`e`是处于`c`的右子树中，那么`e`是一定比`c`的左子树中所有的节点都大的（不论左子树有多复杂）
2. 由于`e`是`c`的右子树中最小的节点，那么也就是说，`c`的右子树中除了`e`自身，其他的所有节点一定比`e`大

综上，我们可以发现，把`e`替换到`c`的位置，该树仍然符合二叉搜索树的基本规则，不会破坏二叉搜索树的结构

删除操作的代码示例如下：
```csharp
public void Delete(int value)
{
    root = DeleteNode(root, value);
}

private TreeNode DeleteNode(TreeNode node, int value)
{
    if (node == null)
        return node;

    if (value < node.Value) // 删除值比当前节点值小，去左子树
    {
        node.Left = DeleteNode(node.Left, value);
    }
    else if (value > node.Value) // 删除值比当前节点值大，去右子树
    {
        node.Right = DeleteNode(node.Right, value);
    }
    else // 相等，找到了删除节点
    {
        if (node.Left == null) // 删除节点只有右子节点
        {
            return node.Right;
        }
        else if (node.Right == null) // 删除节点只有左子节点
        {
            return node.Left;
        }

        // 节点有两个子节点，获取右子树的最小值
        node.Value = MinValue(node.Right); // 使用右子树的最小值替换删掉节点的值

        // 替换了值，记得把右子树最小节点删了
        node.Right = DeleteNode(node.Right, node.Value);
    }

    return node;
}

// 寻找某个节点右子树的最小节点
private int MinValue(TreeNode node)
{
    int minValue = node.Value;
    while (node.Left != null) // 不断循环Left，直到找不到为止
    {
        minValue = node.Left.Value;
        node = node.Left;
    }
    return minValue;
}
```

### 遍历操作

**一、前序遍历（PreOrder）**

访问顺序：中左右
```csharp
public void PreOrder()
{
    PreOrderNode(root);
}

private void PreOrderNode(TreeNode node)
{
    if (node == null)
        return;

    Console.Write(node.Value + " ");
    PreOrderNode(node.Left);
    PreOrderNode(node.Right);
}
```

**二、中序遍历（InOrder）**

访问顺序：左中右

由于左结点都比根结点小，右结点比根结点大，所以中序遍历得到的便是从小到大的序列
```csharp
public void InOrder()
{
    InOrderNode(root);
}

private void InOrderNode(TreeNode node)
{
    if (node == null)
        return;

    InOrderNode(node.Left);
    Console.Write(node.Value + " ");
    InOrderNode(node.Right);
}
```

**三、后序遍历（PostOrder）**

访问顺序：左右中

```csharp
public void PostOrder()
{
    PostOrderNode(root);
    Console.WriteLine();
}

private void PostOrderNode(TreeNode node)
{
    if (node == null)
        return;

    PostOrderNode(node.Left);
    PostOrderNode(node.Right);
    Console.Write(node.Value + " ");
}
```

**四、层序遍历（LevelOrder）**

先遍历某一层，再遍历下一层

```csharp
public void LevelOrder()
{
    if (root == null)
        return; // 空树直接返回

    Queue<TreeNode> queue = new Queue<TreeNode>();
    queue.Enqueue(root); // 根节点入队

    while (queue.Count > 0) // 队列不为空时循环
    {
        TreeNode current = queue.Dequeue(); // 取出队首节点
        Console.Write(current.Value + " "); // 输出该节点值

        if (current.Left != null) // 该节点如果存在左子节点
            queue.Enqueue(current.Left); // 左子节点入队

        if (current.Right != null) // 该节点如果存在右子节点
            queue.Enqueue(current.Right); // 右子节点入队
    }
    Console.WriteLine();
}
```

# 前缀树
### 前言

首先，让我们看看生活中常使用的电子词典，我们发现电子词典除了可以查词之外，其有一个非常重要的功能，可以以前缀来进行搜索，比如：在电子词典中输入 “app”，屏幕立刻弹出 “apple”、“application”“append” 等一系列相关词汇，除此之外，电子词典的查找以及前缀匹配速度是非常快的，而这种高效的自动补全以及前缀补全功能，正是使用前缀树来实现的

### 定义

字典树（Trie），也被称为前缀树、单词查找树，是一种专门用于高效处理字符串匹配的树形数据结构

其核心优势在于利用字符串的公共前缀来减少无意义的操作，大幅提升字符串的插入、查询效率，时间复杂度仅为 $O(k)$（k为字符串的长度）

### 举例

下面以一个最简单的例子为例，来看看前缀树是怎么样的

假设我们需要存储app、appple、append、ban这四个个单词

```plaintext
a -> p -> p(√) -> l -> e(√)
             ↘
               e -> n -> d(√)

b -> a -> n(√)
```
每一个√代表这里是一个单词的结束

# 基本结构

```csharp
public class Trie
{
    // 字典树节点
    private class TrieNode
    {
        public TrieNode[] children; // 子节点(由于是英语字母，假设只处理小写字母，最多26个，这里用数组处理)
        public bool isEnd; // 是否是某个单词的结束

        public TrieNode()
        {
            children = new TrieNode[26];
            isEnd = false;
        }
    }

    private TrieNode _root; // 字典树的根节点（不存储字符）

    public Trie()
    {
        _root = new TrieNode(); // 初始化根节点
    }

    public int GetCharIndex(char c)
    {
        return c - 'a';
    }
}
```

# 关键操作
### 添加单词
```csharp
// 添加单词
public void Insert(string word)
{
    TrieNode curr = _root;
    foreach (char c in word)
    {
        int charIndex = GetCharIndex(c);
        if (curr.children[charIndex] == null)
        {
            curr.children[charIndex] = new TrieNode();
        }
        // 移动到子节点
        curr = curr.children[charIndex];
    }
    curr.isEnd = true; // 迭代结束，标记该节点是一个单词的结束位置
}
```

### 搜索单词
```csharp
// 搜索单词
public bool Search(string word)
{
    TrieNode curr = _root;
    foreach (char c in word)
    {
        int charIndex = GetCharIndex(c);
        if (curr.children[charIndex] == null)
        {
            return false;
        }
        curr = curr.children[charIndex];
    }
    return curr.isEnd; // 必须是完整字符串的结束位置才返回true
}
```

### 前缀匹配
```csharp
// 前缀匹配
public bool StartsWith(string prefix)
{
    TrieNode curr = _root;
    foreach (char c in prefix)
    {
        int charIndex = GetCharIndex(c);
        if (curr.children[charIndex] == null)
        {
            return false;
        }
        
        curr = curr.children[charIndex];
    }
    // 只要前缀路径存在，就返回true（无需验证结束标记）
    return true;
}
```



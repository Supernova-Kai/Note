# 二叉搜索树（递归版）
```csharp
using System;
using System.Collections.Generic;

/// <summary>
/// 二叉搜索树
/// </summary>
public class BinarySearchTree
{
    /// <summary>
    /// 节点结构
    /// </summary>
    private class TreeNode
    {
        public int Value;      // 数据
        public TreeNode Left;  // 左子节点
        public TreeNode Right; // 右子节点

        public TreeNode(int value)
        {
            Value = value;
            Left = null;
            Right = null;
        }
    }

    /// <summary>
    /// 根节点
    /// </summary>
    private TreeNode _root;

    public BinarySearchTree()
    {
        _root = null;
    }

    /// <summary>
    /// 插入
    /// </summary>
    /// <param name="value">插入值</param>
    public void Insert(int value)
    {
        _root = InsertNode(_root, value);
    }

    private TreeNode InsertNode(TreeNode node, int value)
    {
        // 1. 找到了空位置,创建新节点
        if (node == null)
        {
            return new TreeNode(value);
        }

        // 2. 处理重复值（二叉搜索树通常不允许重复）
        if (value == node.Value)
        {
            return node; // 直接返回原节点，不插入
        }

        // 3. 递归查找插入位置，并挂载新节点
        if (value > node.Value) // 插入值比当前节点值大,需要去右边
        {

            node.Right = InsertNode(node.Right, value); // 将递归结果赋值给node.Right，完成挂载
        }
        else // 插入值比当前节点值小,需要去左边
        {
            node.Left = InsertNode(node.Left, value);
        }

        // 4. 返回当前节点（保证上层递归能正确挂载）
        return node;
    }

    /// <summary>
    /// 删除
    /// </summary>
    /// <param name="value">删除值</param>
    public void Delete(int value)
    {
        _root = DeleteNode(_root, value);
    }

    private TreeNode DeleteNode(TreeNode node, int value)
    {
        // 1. 未找到要删除的节点，返回null
        if (node == null)
        {
            return null;
        }

        // 2. 递归查找要删除的节点
        if (value < node.Value) // 删除值比当前节点值小,需要去左边
        {
            node.Left = DeleteNode(node.Left, value); //将删除后的子树重新挂载到node.Left
        }
        else if (value > node.Value) // 删除值比当前节点值大,需要去右边
        {
            node.Right = DeleteNode(node.Right, value);
        }
        else // 找到了值相等的节点
        {
            if (node.Left == null && node.Right == null) // 删除的节点没有左右子节点,直接删除该节点即可
            {
                return null;
            }
            else if (node.Left != null && node.Right == null) // 删除的节点只有左子节点
            {
                return node.Left; // 用左子节点替换当前节点
            }
            else if (node.Right != null && node.Left == null) // 删除的节点只有右子节点
            {
                return node.Right; // 用右子节点替换当前节点
            }
            else // 删除的节点既有左子节点,又有右子节点
            {
                int minValue = MinValue(node.Right); // 找出该节点右子树中的最小值
                node.Value = minValue; // 用该最小值替换删除节点的值
                node.Right = DeleteNode(node.Right, minValue); // 记得去右子树把最小节点删了
            }
        }

        return node;
    }

    /// <summary>
    /// 寻找某个节点的子树中的最小值
    /// </summary>
    private int MinValue(TreeNode node)
    {
        int minValue = node.Value;
        // 二叉搜索树左子树值更小，循环找最左节点
        while (node.Left != null)
        {
            minValue = node.Left.Value;
            node = node.Left;
        }
        return minValue;
    }

    /// <summary>
    /// 检查二叉搜索树中是否存在指定值
    /// </summary>
    /// <param name="value">要查找的整数值</param>
    /// <returns>存在返回 true，不存在返回 false</returns>
    public bool Contains(int value)
    {
        // 调用内部递归方法，从根节点开始查找
        return ContainsRecursive(_root, value);
    }

    /// <summary>
    /// 递归核心方法：在以 currentNode 为根的子树中查找 value
    /// </summary>
    /// <param name="currentNode">当前遍历的节点</param>
    /// <param name="value">目标值</param>
    /// <returns>是否找到</returns>
    private bool ContainsRecursive(TreeNode currentNode, int value)
    {
        // 递归终止条件1：遍历到空节点，说明没找到
        if (currentNode == null)
        {
            return false;
        }

        // 递归终止条件2：找到目标值，直接返回true
        if (currentNode.Value == value)
        {
            return true;
        }

        // 递归分解：根据值的大小，查找左/右子树
        if (value < currentNode.Value)
        {
            // 目标值更小，递归查找左子树
            return ContainsRecursive(currentNode.Left, value);
        }
        else
        {
            // 目标值更大，递归查找右子树
            return ContainsRecursive(currentNode.Right, value);
        }
    }

    /// <summary>
    /// 前序遍历（中左右）
    /// </summary>
    public void PreOrder()
    {
        PreOrderNode(_root);
        Console.WriteLine();
    }

    private void PreOrderNode(TreeNode node)
    {
        if (node == null)
            return;

        Console.Write(node.Value + " ");
        PreOrderNode(node.Left);
        PreOrderNode(node.Right);
    }

    /// <summary>
    /// 中序遍历（左中右）
    /// </summary>
    public void InOrder()
    {
        InOrderNode(_root);
        Console.WriteLine();
    }

    private void InOrderNode(TreeNode node)
    {
        if (node == null)
            return;

        InOrderNode(node.Left);
        Console.Write(node.Value + " ");
        InOrderNode(node.Right);
    }

    /// <summary>
    /// 后序遍历（左右中）
    /// </summary>
    public void PostOrder()
    {
        PostOrderNode(_root);
        Console.WriteLine();
    }

    private void PostOrderNode(TreeNode node)
    {
        if (node == null)
            return;

        PostOrderNode(node.Left);
        PostOrderNode(node.Right);
        Console.Write(node.Value + " ");
    }

    /// <summary>
    /// 层序遍历
    /// </summary>
    public void LevelOrder()
    {
        if (_root == null)
            return; // 空树直接返回

        Queue<TreeNode> queue = new Queue<TreeNode>();
        queue.Enqueue(_root); // 根节点入队

        while (queue.Count > 0) // 队列不为空时循环
        {
            TreeNode current = queue.Dequeue(); // 取出队首节点
            Console.Write(current.Value + " "); // 输出该节点值

            if (current.Left != null) // 该节点如果存在左子节点
                queue.Enqueue(current.Left); // 左子节点入队

            if (current.Right != null) // 该节点如果存在右子节点
                queue.Enqueue(current.Right); // 右子节点入队
        }
        Console.WriteLine();
    }
}

```

# 二叉搜索树（迭代版）
```csharp
/// <summary>
/// 二叉搜索树（迭代版）
/// </summary>
public class BinarySearchTree
{
    /// <summary>
    /// 节点结构
    /// </summary>
    private class TreeNode
    {
        public int Value;      // 数据
        public TreeNode Left;  // 左子节点
        public TreeNode Right; // 右子节点

        public TreeNode(int value)
        {
            Value = value;
            Left = null;
            Right = null;
        }
    }

    /// <summary>
    /// 根节点
    /// </summary>
    private TreeNode _root;

    public BinarySearchTree()
    {
        _root = null;
    }

    /// <summary>
    /// 插入
    /// </summary>
    /// <param name="value">插入值</param>
    public void Insert(int value)
    {
        // 1. 根节点为空,是一个空树,初始化根节点
        if (_root == null)
        {
            _root = new TreeNode(value);
        }
        
        // 2. 根节点不为空,迭代寻找插入位置
        
        TreeNode current = _root; // 当前节点
        TreeNode parent = null;   // 当前节点的父节点

        while (current != null) // 不断迭代寻找,直到找到空位
        {
            if (current.Value == value) // 重复值不能插入
            {
                return;
            }
            
            parent = current;
            if (value < current.Value) // 插入值比当前节点值小,去左边继续迭代
            {
                current = current.Left;
            }
            else // 插入值比当前节点值大,去右边继续迭代
            {
                current = current.Right;
            }
        }
        
        // 3. 找到了插入位置,创建新节点并与父节点建立引用
        if (value < parent.Value) // 比父节点值小,初始化为父节点的左子节点
        {
            parent.Left = new TreeNode(value);
        }
        else // 比父节点值大,初始化为父节点的右子节点
        {
            parent.Right = new TreeNode(value);
        }
    }

    /// <summary>
    /// 删除
    /// </summary>
    /// <param name="value">删除值</param>
    public void Delete(int value)
    {
        // 1. 根节点为空,是一个空树,直接返回
        if (_root == null)
        {
            return;
        }
        
        // 2. 根节点不为空,迭代寻找删除的节点
        TreeNode current = _root; // 当前节点
        TreeNode parent = null;   // 当前节点的父节点
        bool isLeftChild = false; // 当前节点是否是它的父节点的左子节点

        while (current != null && current.Value != value) // 不断迭代,直到找到
        {
            parent = current;
            if (value < current.Value) // 删除值比当前节点值小,去左边继续迭代
            {
                current = current.Left;
                isLeftChild = true;
            }
            else // 删除值比当前节点值大,去右边继续迭代
            {
                current = current.Right;
                isLeftChild = false;
            }
        }

        if (current == null) // 如果current为空,说明树中没有该元素,直接返回
            return;
        
        // 3. 根据当前节点子节点个数分情况处理

        if (current.Left == null && current.Right == null) // 情况1,删除节点即没有左子节点,也没有右子节点
        {
            if (parent == null) // parent为空,说明删除的是根节点,需要将_root置空
            {
                _root = null;
            }
            else // 删除的不是根节点
            {
                if (isLeftChild) // 删除节点是它的父节点的左子节点,并且删除节点没有左子节点和右子节点,修改父节点的左子节点指向空
                {
                    parent.Left = null;
                }
                else
                {
                    parent.Right = null;
                }
            }
        }
        else if (current.Left != null && current.Right == null) // 删除节点只有左子节点
        {
            if (parent == null) // 删除的是根节点,需要让删除节点的左子节点成为新的根节点
            {
                _root = current.Left;
            }
            else // 删除的不是根节点
            {
                if (isLeftChild) // 删除节点是它父节点的左子节点,修改它父节点的左指向删除节点的左子节点
                {
                    parent.Left = current.Left;
                }
                else
                {
                    parent.Right = current.Left;
                }
            }
        }
        else if (current.Left == null && current.Right != null) // 删除节点只有右子节点
        {
            if (parent == null) // 删除的是根节点,需要让删除节点的左子节点成为新的根节点
            {
                _root = current.Right;
            }
            else // 删除的不是根节点
            {
                if (isLeftChild) // 删除节点是它父节点的左子节点,修改它父节点的左指向删除节点的右子节点
                {
                    parent.Left = current.Right;
                }
                else
                {
                    parent.Right = current.Right;
                }
            }
        }
        else // 删除节点既有左子节点又有右子节点
        {
            // 找到右子树的最小节点（也可以找左子树最大节点）
            TreeNode minNode = current.Right;
            TreeNode minNodeParent = current;

            // 迭代找右子树的最左节点（最小值）
            while (minNode.Left != null)
            {
                minNodeParent = minNode;
                minNode = minNode.Left;
            }

            // 替换当前节点的值为右子树最小节点的值
            current.Value = minNode.Value;

            // 删除这个最左节点(最左节点是右子树中最小的,它只有可能有右子节点,不可能有左子节点)
            if (minNodeParent == current) // 如果最左节点的父节点就是当前节点,那么修改当前节点的Right指向最左节点的Right
                current.Right = minNode.Right;
            else // 如果不是那就修改它的父节点的Left
                minNodeParent.Left = minNode.Right;
        }
    }

    /// <summary>
    /// 是否存在某个值
    /// </summary>
    /// <param name="value">查找值</param>
    /// <returns>true - 存在/false - 不存在</returns>
    public bool Contains(int value)
    {
        if (_root == null)
        {
            return false;
        }
        
        TreeNode current = _root;

        while (current != null)
        {
            if (current.Value == value)
            {
                return true;
            }
            else
            {
                if (value < current.Value)
                    current = current.Left;
                else
                    current = current.Right;
            }
        }
        
        return false;
    }
}
```
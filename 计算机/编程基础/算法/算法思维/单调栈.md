# 单调栈
### 题目
假设现在有这么一个问题

给定一个`int`类型的数组`temperatures`，其中每个元素表示每天的气温，需要返回一个长度相同的数组`result`，`result[i]`表示对于第`i`天，下一个比当前气温更高的气温与当前气温的差值；若之后没有更高气温，`result[i]`为`-1`

更高的气温指：**严格大于**的气温，等于不视为更高

## 传统解决思路

这个问题最直观的思路是暴力遍历：对于每一个元素，向后逐个查找第一个严格大于的元素，找到后计算差值，未找到则为默认值`0`

### 具体代码

```csharp
public class Solution
{
    public int[] DailyTemperatureDiff(int[] temperatures)
    {
        int[] result = new int[temperatures.Length];
        
        // 遍历每一天
        for (int i = 0; i < temperatures.Length; i++)
        {
            int currentTemp = temperatures[i];
            // 向后查找第一个严格大于的温度
            for (int j = i + 1; j < temperatures.Length; j++)
            {
                if (temperatures[j] > currentTemp)
                {
                    result[i] = temperatures[j] - currentTemp;
                    break; // 找到后立即退出内层循环
                }
            }
        }
        
        return result;
    }
}
```

### 传统思路的问题

该算法使用了嵌套两次循环来解决此问题，我们可以很明显的看出该算法的时间复杂度为 $O(n^2)$，再面对大规模数据时，其表现不理想

## 单调栈思维
### 具体代码
```csharp
public class Solution
{
    public int[] DailyTemperatureDiff(int[] temperatures)
    {
        Stack<int> stack = new Stack<int>();
        int[] result = new int[temperatures.Length];

        // 从后往前遍历
        for (int i = temperatures.Length - 1; i >= 0; i--)
        {
            int currentTemp = temperatures[i]; // 当前温度

            // 先对栈中元素进行处理，弹出栈中所有温度小于等于当前温度的（无效候选）
            while (stack.Count > 0 && stack.Peek() <= currentTemp)
            {
                stack.Pop();
            }

            // 对栈处理完之后，如果栈不为空，说明栈顶元素就是在“当前元素之后，第一个严格大于当前温度的”
            if (stack.Count > 0)
            {
                result[i] = stack.Peek() - currentTemp;
            }

            // 将当前气温压入栈，作为左侧元素的候选
            stack.Push(currentTemp);
        }

        return result;
    }
}
```

### 总结
- 单调栈解法利用**空间换时间**，通过维护**有效候选元素**的栈，将时间复杂度优化至

O(n)，是解决 “下一个更大元素” 类问题的最优思路

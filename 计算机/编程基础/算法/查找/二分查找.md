# 二分查找

### 前提条件

要使用二分查找的集合，其前提条件是必须得是有序的

### 原理

首先，由于我们的集合是有序的（假设是升序），我们找到集合正中间的元素值，将其与目标值进行比较，此时分为三种情况：

​	1.中间值与目标值相等，说明找到了

​	2.中间值小于目标值，说明目标值在中间值的右半部分

​	3.中间值大于目标值，说明目标值在中间值的左半部分

接下来，我们只需要根据情况，在右半部分或者左半部分，重复上面的操作即可

# 代码示例

```c#
// 这里的array必须是排好序之后的数组
public bool BinarySearch(int[] array, int target)
{
    int left = 0; // 左边界
    int right = array.Length - 1; // 右边界

    while (left <= right)
    {
        int mid = left + (right - left) / 2; // 中间索引，这里不用(left + right) / 2 的原因是，防止超出int的上限
        int midValue = array[mid]; // 中间值

        if (midValue == target) // 等于目标值，直接返回
        {
            return true;
        }
        else if (midValue < target) // 中间值小于目标值，说明目标值在中间值的右边
        {
            left = mid + 1; // 调整左边界为mid + 1
        }
        else if (midValue > target) // 中间值大于目标值，说明目标值在中间值的左边
        {
            right = mid - 1; // 调整右边界为mid - 1
        }
    }
    return false; // 一定不要忘了处理没找到的情况
}
```

# 复杂度分析

### 时间复杂度

- 最好情况：元素刚好在最中间，第一次就能找到，时间复杂度为 $O(1)$
- 最差情况：集合里面没有这个元素或者处于最后一次查找的位置，但是因为每一次都能排除一半的元素，所以时间复杂度是 $O(log_2n)$

综上，二分查找的时间复杂度为 $O(log_2 n)$

### 空间复杂度

未开辟新空间，空间复杂度为 $O(1)$

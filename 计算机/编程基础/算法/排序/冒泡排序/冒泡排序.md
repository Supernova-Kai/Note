# 冒泡排序
### 原理

下面以`n`表示集合的长度

1. 外层循环控制轮数，需要`n-1`轮（因为我们是通过交换相邻的元素进行排序，如果最后两个元素是相反的，只需要一次便可将两个的顺序一起排好）
2. 内层循环遍历未排序的部分，比较相邻的两个数字，将较大的数字不断后移
# 代码示例
```csharp
public void BubbleSort(int[] array)
{
    for (int i = 0; i < array.Length - 1; i++) // 集合长度为n，只需要n-1次就可完成排序
    {
        for (int j = 0; j < array.Length - 1 - i; j++) // 从前到尾进行冒泡，未排序部分最大的数便会不断冒泡到末尾
        {
            if (array[j + 1] < array[j])
            {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;
            }
        }
    }
}
```
# 复杂度分析

- 时间复杂度： $O(n^2)$ （但是内层循环需要不断比较和交换相邻的元素，性能较差）
- 空间复杂度：不开辟新空间，为 $O(1)$

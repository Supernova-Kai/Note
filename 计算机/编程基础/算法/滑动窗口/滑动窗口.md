## 问题
假设现在有这样一个问题

给定一个int类型的数组`arr`，元素值已经提前设置好，其中每`k`个连续的元素为一个区间，我们需要统计`arr`中有多少个区间满足：“区间内的元素的总和等于另一个输入值`target`”


## 传统解决思路

这个问题并不难，我们只需要迭代每一个区间，将每一个区间内的`k`个元素加起来，检查总和是否等于目标值`target`即可

### 具体代码

```csharp
public class Solution
{
    public int GetCount(int[] arr,int k, int target)
    {
        int result = 0;

        for (int i = 0; i <= arr.Length - k; i++)
        {
            if (GetSum(arr, i, k) == target)
                result++;
        }
        
        return result;
    }

    // 获取数组某个区间内的元素之和
    // 区间:[startIndex, startIndex + length - 1]
    public int GetSum(int[] arr, int startIndex, int length)
    {
        int sum = 0;
        for (int i = 0; i < length; i++)
        {
            sum += arr[startIndex + i];
        }
        return sum;
    }
}
```

### 传统思路的问题

我们看一下上面的代码，假设我们的`arr`长度为`n`，那么`arr`的最后一个索引就是`n-1`，最后一个区间的第一个元素索引就是`(n-1)-(k-1)=n-k`，最后一个区间就是 $[n-k,n-1]$ ，那么一共就是 $(n-k+1)$ 个区间，每一个区间需要累加`k`个元素，那么一共就是 $(n-k+1)*k$ 次运算

假设`arr`的长度为`10000`，`k=100`，那么代入可得会有`990,100`次运算，该算法的性能显然是不理想的


## 滑动窗口思维
### 优化思路

首先我们从第一个区间开始思考，假设`k=100`，那么第一个区间就是 $[0,99]$ ，第二个区间就是 $[1,100]$ ，我们看看这两个区间的差异，我们发现它们只有两个元素的差异（ $arr[0]$ 被移除了， $arr[100]$ 进入了），那么我们其实只需要处理两个元素就可以了，并不需要像上面的做法一样，每一次都去计算整个区间的元素和

### 具体代码

```csharp
public class Solution
{
    public int GetCount(int[] arr, int k, int target)
    {
        int result = 0;

        // 首先计算第一个窗口的元素和
        int sum = 0;
        for (int i = 0; i < k; i++)
        {
            sum += arr[i];
        }

        // 检查第一个窗口是否满足条件
        if (sum == target)
            result++;
        
        // 迭代后续的窗口
        for (int j = 0; j < arr.Length - k; j++)
        {
            sum -= arr[j]; // 减去离开窗口的元素
            sum += arr[j + k]; // 加上进入窗口的元素
            
            if (sum == target) // 检查是否满足条件
                result++;
        }

        return result;
    }
}
```

在上面的代码中，我们首先计算出第一个窗口的元素和并检查是否满足条件，当窗口移动到下一个位置时，我们只计算离开窗口和进入窗口的**两个元素**，这样大大减少了计算量


以`arr`长度为`10000`，`k=100`为例，我们来计算一下计算次数，首先，我们需要计算第一个窗口的元素和，这里有`100`次计算，然后对于剩下的`9901`个区间，我们每次只计算了两个元素，那么一共就是 $100+9901*2=19,902$ 次计算，相较于传统做法，性能有了很大的提升

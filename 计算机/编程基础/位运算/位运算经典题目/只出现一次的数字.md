# 题目
LeetCode第136题，只出现一次的数字

给你一个非空整数数组`nums`，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间

## 思路
题目中要求用“**线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间**”，那么哈希法不满足使用常量额外空间的要求，不能使用

### 异或运算
对于异或运算，有：**同为0，异为1**

接下来我们看下面两种情况：

1. 如果一个数与自己进行异或，也就是`n ^ n`，由于是相同的数进行异或，左边的`n`与右边的`n`，其二进制的每一位都是相同的，根据”同为0“，其最终结果每一位都是`0`，即`n ^ n = 0`
2. 如果一个数与0进行异或，对于1，1与0是不同的，根据“异为1”，可得到1 ^ 0 = 1；对于0，0与0是相同的，根据“同为0”，可得到0 ^ 0 = 0。那么我们可以得到，一个数n与0进行异或，由于0的每一位都是0，其异或的结果完全由n的每一位决定，并且n的对应位是1就会得到1，是0就会得到0，也就是说n ^ 0 = n
那么我们可以得到异或的两个结论：

```c
n ^ n = 0 // 同为0
n ^ 0 = n // 0与任何数异或等于原数

// 除此之外，异或操作的顺序不影响结果，即满足交换律
a ^ b = b ^ a
```

那么，回到我们的题目，根据题意，输入的数组，除了一个数字之外，其余所有数字都是“出现且恰好出现了两次”，那么我们只需要不断进行异或运算，就可以消掉所有出现了两次的数字，得到0，而我们需要找的数字只出现了一次，0与其异或仍然保留原值，我们就可以得到需要找的那个数字
## 代码
```csharp
public int SingleNumber(int[] nums) {
    int result = 0;
    for (int i = 0; i < nums.Length; i++)
    {
      result ^= nums[i];
    }
    return result;
}
```
